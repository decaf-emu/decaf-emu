#!/usr/bin/perl
#
# Usage: $0 gl.h glext.h >gl.cpp

use strict;
use warnings;

my %funcs = ();
while (<>) {
    s|/\*.*?\*/||;
    s|//.*||;
    if (/^\s*GLAPI\s+(.*?\S)\s*(?:GL)?APIENTRY\s+(gl[A-Z]\w+)\s*\(/) {
        while (!/\);\s*$/) {
            $_ .= <>;
        }
    }
    if (/^\s*GLAPI\s+(.*?\S)\s*(?:GL)?APIENTRY\s+(gl[A-Z]\w+)\s*\(\s*((?:.|\n)*\S)\s*\);/) {
        my ($rettype, $name, $params) = ($1, $2, $3);
        my $args;
        if ($params eq "void") {
            $args = "";
        } else {
            my @params = ();
            foreach my $param (split(/\s*,\s*/, $params)) {
                my $type = $param;
                my $array = undef;
                $type =~ s/((?:\s*\[\d+\])+)$// and $array = $1;
                $type =~ s/(\w+)$// or die "bad param: $param";
                my $pname = $1;
                $type =~ s/\s+$//;
                my $decl = $type;
                $decl .= " " if $decl =~ /\w$/;
                $decl .= $pname;
                $decl .= $array if $array;
                push @params, [$decl, $pname];
            }
            $params = join(", ", map {$$_[0]} @params);
            $args = join(", ", map {$$_[1]} @params);
        }
        my $basename = $name;
        $basename =~ s/(ARB|EXT|KHR|OES|3DFX|AMD|APPLE|ATI|GREMEDY|HP|IBM|INGR|INTEL|MESA|NV[X]?|OVR|PGI|SGI[SX]?|SUN[X]?)$//;
        if (!$funcs{$basename}) {
            $funcs{$basename} = {rettype => $rettype,
                                 params => $params,
                                 args => $args,
                                 aliases => []};
        }
        push @{$funcs{$basename}{aliases}}, $name if $name ne $basename;
    }
}

print <<EOT;
// This file is automatically generated.

#ifndef DECAF_NOGL
#ifndef DECAF_GLBINDING

#include "common/decaf_assert.h"
#include "common/gl.h"
#include "common/log.h"
#include "common/platform_opengl.h"

template <typename RetType, typename FuncPtrType, typename... Params>
RetType trampoline(const char *name,
                   const char *altName1,
                   const char *altName2,
                   const char *altName3,
                   FuncPtrType *funcPtr,
                   Params... params)
{
    *funcPtr = reinterpret_cast<FuncPtrType>(platform::lookupGLFunction(name));
    if (altName1 && !*funcPtr) {
        *funcPtr = reinterpret_cast<FuncPtrType>(platform::lookupGLFunction(altName1));
    }
    if (altName2 && !*funcPtr) {
        *funcPtr = reinterpret_cast<FuncPtrType>(platform::lookupGLFunction(altName2));
    }
    if (altName3 && !*funcPtr) {
        *funcPtr = reinterpret_cast<FuncPtrType>(platform::lookupGLFunction(altName3));
    }
    decaf_assert(*funcPtr, fmt::format("Failed to look up {}", name));

    return (*funcPtr)(params...);
}

EOT

foreach my $func (sort(keys(%funcs))) {
    my $data = $funcs{$func};
    my $rettype = $data->{rettype};
    my $params = $data->{params};
    my $args = $data->{args};
    my $aliases = join(", ", ((map {"\"$_\""} @{$data->{aliases}}),
                              "nullptr", "nullptr", "nullptr")[0..2]);
    my $comma_args = $args ? ", $args" : "";
    print <<EOT;
static $rettype wrap_$func($params);
static $rettype (APIENTRYP p$func)($params) = wrap_$func;
static $rettype wrap_$func($params) {return trampoline<$rettype>("$func", $aliases, &p$func$comma_args);}
extern "C" $rettype APIENTRY $func($params) {return (*p$func)($args);}
EOT
}

print <<EOT;

#endif // DECAF_GLBINDING
#endif // !DECAF_NOGL
EOT
